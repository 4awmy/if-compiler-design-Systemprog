# `ParserLogic.py` - Detailed Documentation

## 1. Overview
`ParserLogic.py` implements the **Syntax Analysis** phase of the compiler. Its primary role is to take the flat list of tokens generated by the `LexicalAnalyzer` and build an **Abstract Syntax Tree (AST)**. This tree represents the grammatical structure of the code, making it easier for later phases to understand and process.

This parser uses a technique called **Recursive Descent Parsing**.

## 2. The `Parser` Class
This is the main class that encapsulates the parsing logic.

### `__init__(self, tokens)`
The constructor initializes the parser's state.
```python
def __init__(self, tokens):
    self.tokens = tokens
    self.pos = 0
    self.current_token = self.tokens[self.pos]
```
- **`tokens`**: A list of `Token` objects from the `LexicalAnalyzer`.
- **`pos`**: An integer that acts as a cursor, pointing to the current position in the `tokens` list.
- **`current_token`**: The token object at the current position (`self.pos`).

### `eat(self, token_type)`
This is a helper method that is fundamental to the parser's operation.
```python
def eat(self, token_type):
    if self.current_token.type == token_type:
        self.pos += 1
        if self.pos < len(self.tokens):
            self.current_token = self.tokens[self.pos]
    else:
        raise Exception(f"Syntax Error: Expected {token_type}, found {self.current_token.type}")
```
Its job is to "consume" the current token if it matches the expected `token_type`.
- **If it matches**: It advances the `pos` cursor to the next token.
- **If it does not match**: It raises a `Syntax Error`, because the code does not conform to the expected grammar.

## 3. Parsing Methods
The parser is a set of mutually recursive methods, where each method is responsible for parsing a specific part of the language's grammar.

### `parse(self)`
This is the main entry point for the parser.
```python
def parse(self):
    """Entry point for the parser"""
    return self.parse_if_statement()
```
In this simple compiler, the only top-level statement supported is an `if` statement, so this method directly calls `parse_if_statement`.

### `parse_if_statement(self)`
This method parses an `if-else` statement according to the following grammar rule:
`'if' '(' Condition ')' '{' Block '}' ['else' '{' Block '}']`

It uses the `eat()` method to consume tokens in the expected order (`IF`, `LPAREN`, etc.) and calls other parsing methods (`parse_condition`, `parse_block`) to handle the nested parts of the statement. It constructs and returns an `IfStatement` AST node.

### `parse_condition(self)`
This method parses the condition part of an `if` statement. The expected grammar is:
`ID OP (ID | NUMBER)`

It reads an identifier, an operator, and then another identifier or a number, and constructs a `BinOp` (Binary Operation) AST node to represent the condition.

### `parse_block(self)`
This method parses a block of statements enclosed in curly braces (`{}`). A block is defined as a sequence of zero or more assignment statements.
`Assignment*`

It repeatedly calls `parse_assignment` (implicitly, as the logic is inside a `while` loop) until it no longer finds an `ID` token, which signals the start of an assignment. It collects all the `Assignment` nodes in a list and returns it.

#### Assignment Parsing Logic (within `parse_block`)
The grammar for an assignment is:
`ID '=' (ID | NUMBER) ';'`

The loop within `parse_block` handles this:
1. It expects an `ID` (the variable name).
2. It `eat`s the `ASSIGN` (`=`) token.
3. It checks for either a `NUMBER` or an `ID` for the value.
4. It `eat`s the `SEMI` (`;`) token.
5. It creates an `Assignment` node and adds it to the list of statements.

## 4. How it Works: An Example
Let's trace the parsing of `if (x > 10) { y = 5; }`:

1.  **`parse()`** calls **`parse_if_statement()`**.
2.  **`parse_if_statement()`**:
    - `eat('IF')`: Consumes the `if` token.
    - `eat('LPAREN')`: Consumes `(`.
    - Calls **`parse_condition()`**:
        - Reads `x` and creates a `Variable` node. `eat('ID')`.
        - Reads `>` and stores it as the operator. `eat('OP')`.
        - Reads `10` and creates a `Number` node. `eat('NUMBER')`.
        - Returns a `BinOp` node: `BinOp(Variable('x'), '>', Number(10))`.
    - `eat('RPAREN')`: Consumes `)`.
    - `eat('LBRACE')`: Consumes `{`.
    - Calls **`parse_block()`**:
        - Enters the `while` loop because the current token is `ID` (`y`).
        - Reads `y` as `var_name`. `eat('ID')`.
        - `eat('ASSIGN')`: Consumes `=`.
        - Reads `5` and creates a `Number` node. `eat('NUMBER')`.
        - `eat('SEMI')`: Consumes `;`.
        - Creates an `Assignment` node and adds it to the `statements` list.
        - The next token is `RBRACE`, so the `while` loop terminates.
        - Returns the list `[Assignment('y', Number(5))]`.
    - `eat('RBRACE')`: Consumes `}`.
    - The next token is `EOF`, not `ELSE`, so `else_body` remains `None`.
3.  Finally, `parse_if_statement` returns the complete `IfStatement` AST node.
